// Generated by CoffeeScript 1.4.0
(function() {
  var $w, beforeAfter, expect, expectDayResetNoDamage, expectLostPoints, expectNoChange, moment, newUser, repeatWithoutLastWeekday, rewrapUser, shared, sinon, test_helper, _;

  _ = require('lodash');

  expect = require('expect.js');

  sinon = require('sinon');

  moment = require('moment');

  shared = require('../../common/script/index.js');

  shared.i18n.translations = require('../../website/src/libs/i18n.js').translations;

  test_helper = require('./test_helper');

  test_helper.addCustomMatchers();

  $w = function(s) {
    return s.split(' ');
  };

  /* Helper Functions
  */


  newUser = function(addTasks) {
    var buffs, user;
    if (addTasks == null) {
      addTasks = true;
    }
    buffs = {
      per: 0,
      int: 0,
      con: 0,
      str: 0,
      stealth: 0,
      streaks: false
    };
    user = {
      auth: {
        timestamps: {}
      },
      stats: {
        str: 1,
        con: 1,
        per: 1,
        int: 1,
        mp: 32,
        "class": 'warrior',
        buffs: buffs
      },
      items: {
        lastDrop: {
          count: 0
        },
        hatchingPotions: {},
        eggs: {},
        food: {},
        gear: {
          equipped: {},
          costume: {},
          owned: {}
        },
        quests: {}
      },
      party: {
        quest: {
          progress: {
            down: 0
          }
        }
      },
      preferences: {
        autoEquip: true
      },
      dailys: [],
      todos: [],
      rewards: [],
      flags: {},
      achievements: {
        ultimateGearSets: {}
      },
      contributor: {
        level: 2
      },
      _tmp: {}
    };
    shared.wrap(user);
    user.ops.reset(null, function() {});
    if (addTasks) {
      _.each(['habit', 'todo', 'daily'], function(task) {
        return user.ops.addTask({
          body: {
            type: task,
            id: shared.uuid()
          }
        });
      });
    }
    return user;
  };

  rewrapUser = function(user) {
    user._wrapped = false;
    shared.wrap(user);
    return user;
  };

  beforeAfter = function(options) {
    var after, before, lastCron, user, _ref;
    if (options == null) {
      options = {};
    }
    user = newUser();
    _ref = [user, _.cloneDeep(user)], before = _ref[0], after = _ref[1];
    rewrapUser(after);
    if (options.dayStart) {
      before.preferences.dayStart = after.preferences.dayStart = options.dayStart;
    }
    before.preferences.timezoneOffset = after.preferences.timezoneOffset = options.timezoneOffset || moment().zone();
    if (options.limitOne) {
      before["" + options.limitOne + "s"] = [before["" + options.limitOne + "s"][0]];
      after["" + options.limitOne + "s"] = [after["" + options.limitOne + "s"][0]];
    }
    if (options.daysAgo) {
      lastCron = moment(options.now || +(new Date)).subtract({
        days: options.daysAgo
      });
    }
    if (options.daysAgo && options.cronAfterStart) {
      lastCron.add({
        hours: options.dayStart,
        minutes: 1
      });
    }
    if (options.daysAgo) {
      lastCron = +lastCron;
    }
    _.each([before, after], function(obj) {
      if (options.daysAgo) {
        return obj.lastCron = lastCron;
      }
    });
    return {
      before: before,
      after: after
    };
  };

  expectLostPoints = function(before, after, taskType) {
    if (taskType === 'daily' || taskType === 'habit') {
      expect(after.stats.hp).to.be.lessThan(before.stats.hp);
      expect(after["" + taskType + "s"][0].history).to.have.length(1);
    } else {
      expect(after.history.todos).to.have.length(1);
    }
    expect(after).toHaveExp(0);
    expect(after).toHaveGP(0);
    return expect(after["" + taskType + "s"][0].value).to.be.lessThan(before["" + taskType + "s"][0].value);
  };

  expectNoChange = function(before, after) {
    return _.each($w('stats items gear dailys todos rewards preferences'), function(attr) {
      return expect(after[attr]).to.eql(before[attr]);
    });
  };

  expectDayResetNoDamage = function(b, a) {
    var after, before, _ref;
    _ref = [_.cloneDeep(b), _.cloneDeep(a)], before = _ref[0], after = _ref[1];
    _.each(after.dailys, function(task, i) {
      expect(task.completed).to.be(false);
      expect(before.dailys[i].value).to.be(task.value);
      expect(before.dailys[i].streak).to.be(task.streak);
      return expect(task.history).to.have.length(1);
    });
    _.each(after.todos, function(task, i) {
      expect(task.completed).to.be(false);
      return expect(before.todos[i].value).to.be.greaterThan(task.value);
    });
    expect(after.history.todos).to.have.length(1);
    _.each([before, after], function(obj) {
      delete obj.stats.buffs;
      return _.each($w('dailys todos history lastCron'), function(path) {
        return delete obj[path];
      });
    });
    delete after._tmp;
    return expectNoChange(before, after);
  };

  repeatWithoutLastWeekday = function() {
    var repeat;
    repeat = {
      su: true,
      m: true,
      t: true,
      w: true,
      th: true,
      f: true,
      s: true
    };
    if (shared.startOfWeek(moment().zone(0)).isoWeekday() === 1) {
      repeat.su = false;
    } else {
      repeat.s = false;
    }
    return {
      repeat: repeat
    };
  };

  describe('Cron', function() {
    it('computes shouldCron', function() {
      var paths, user;
      user = newUser();
      paths = {};
      user.fns.cron({
        paths: paths
      });
      expect(user.lastCron).to.not.be.ok;
      user.lastCron = +moment().subtract(1, 'days');
      paths = {};
      user.fns.cron({
        paths: paths
      });
      return expect(user.lastCron).to.be.greaterThan(0);
    });
    it('only dailies & todos are affected', function() {
      var after, afterTasks, before, beforeTasks, _ref;
      _ref = beforeAfter({
        daysAgo: 1
      }), before = _ref.before, after = _ref.after;
      before.dailys = before.todos = after.dailys = after.todos = [];
      after.fns.cron();
      before.stats.mp = after.stats.mp;
      expect(after.lastCron).to.not.be(before.lastCron);
      delete after.stats.buffs;
      delete before.stats.buffs;
      expect(before.stats).to.eql(after.stats);
      beforeTasks = before.habits.concat(before.dailys).concat(before.todos).concat(before.rewards);
      afterTasks = after.habits.concat(after.dailys).concat(after.todos).concat(after.rewards);
      return expect(beforeTasks).to.eql(afterTasks);
    });
    describe('preening', function() {
      beforeEach(function() {
        return this.clock = sinon.useFakeTimers(Date.parse("2013-11-20"), "Date");
      });
      afterEach(function() {
        return this.clock.restore();
      });
      return it('should preen user history', function() {
        var after, before, history, _ref;
        _ref = beforeAfter({
          daysAgo: 1
        }), before = _ref.before, after = _ref.after;
        history = [
          {
            date: '09/01/2012',
            value: 0
          }, {
            date: '10/01/2012',
            value: 0
          }, {
            date: '11/01/2012',
            value: 2
          }, {
            date: '12/01/2012',
            value: 2
          }, {
            date: '01/01/2013',
            value: 1
          }, {
            date: '01/15/2013',
            value: 3
          }, {
            date: '02/01/2013',
            value: 2
          }, {
            date: '02/15/2013',
            value: 4
          }, {
            date: '03/01/2013',
            value: 3
          }, {
            date: '03/15/2013',
            value: 5
          }, {
            date: '04/01/2013',
            value: 4
          }, {
            date: '04/15/2013',
            value: 6
          }, {
            date: '05/01/2013',
            value: 5
          }, {
            date: '05/15/2013',
            value: 7
          }, {
            date: '06/01/2013',
            value: 6
          }, {
            date: '06/15/2013',
            value: 8
          }, {
            date: '07/01/2013',
            value: 7
          }, {
            date: '07/15/2013',
            value: 9
          }, {
            date: '08/01/2013',
            value: 8
          }, {
            date: '08/15/2013',
            value: 10
          }, {
            date: '09/01/2013',
            value: 9
          }, {
            date: '09/15/2013',
            value: 11
          }, {
            date: '010/01/2013',
            value: 10
          }, {
            date: '010/15/2013',
            value: 12
          }, {
            date: '011/01/2013',
            value: 12
          }, {
            date: '011/02/2013',
            value: 13
          }, {
            date: '011/03/2013',
            value: 14
          }, {
            date: '011/04/2013',
            value: 15
          }
        ];
        after.history = {
          exp: _.cloneDeep(history),
          todos: _.cloneDeep(history)
        };
        after.habits[0].history = _.cloneDeep(history);
        after.fns.cron();
        after.history.exp.pop();
        after.history.todos.pop();
        return _.each([after.history.exp, after.history.todos, after.habits[0].history], function(arr) {
          return expect(_.map(arr, function(x) {
            return x.value;
          })).to.eql([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
        });
      });
    });
    describe('Todos', function() {
      it('1 day missed', function() {
        var after, before, _ref;
        _ref = beforeAfter({
          daysAgo: 1
        }), before = _ref.before, after = _ref.after;
        before.dailys = after.dailys = [];
        after.fns.cron();
        expect(after).toHaveHP(50);
        expect(after).toHaveExp(0);
        expect(after).toHaveGP(0);
        expect(before.todos[0].value).to.be(0);
        expect(after.todos[0].value).to.be(-1);
        return expect(after.history.todos).to.have.length(1);
      });
      return it('2 days missed', function() {
        var after, before, _ref;
        _ref = beforeAfter({
          daysAgo: 2
        }), before = _ref.before, after = _ref.after;
        before.dailys = after.dailys = [];
        after.fns.cron();
        expect(before.todos[0].value).to.be(0);
        return expect(after.todos[0].value).to.be(-1);
      });
    });
    describe('cron day calculations', function() {
      var dayStart, fstr;
      dayStart = 4;
      fstr = "YYYY-MM-DD HH:mm:ss";
      it('startOfDay before dayStart', function() {
        var start;
        start = shared.startOfDay({
          now: moment('2014-10-09 02:30:00'),
          dayStart: dayStart
        });
        return expect(start.format(fstr)).to.eql('2014-10-08 04:00:00');
      });
      it('startOfDay after dayStart', function() {
        var start;
        start = shared.startOfDay({
          now: moment('2014-10-09 05:30:00'),
          dayStart: dayStart
        });
        return expect(start.format(fstr)).to.eql('2014-10-09 04:00:00');
      });
      it('daysSince cron before, now after', function() {
        var days, lastCron;
        lastCron = moment('2014-10-09 02:30:00');
        days = shared.daysSince(lastCron, {
          now: moment('2014-10-09 11:30:00'),
          dayStart: dayStart
        });
        return expect(days).to.eql(1);
      });
      it('daysSince cron before, now before', function() {
        var days, lastCron;
        lastCron = moment('2014-10-09 02:30:00');
        days = shared.daysSince(lastCron, {
          now: moment('2014-10-09 03:30:00'),
          dayStart: dayStart
        });
        return expect(days).to.eql(0);
      });
      it('daysSince cron after, now after', function() {
        var days, lastCron;
        lastCron = moment('2014-10-09 05:30:00');
        days = shared.daysSince(lastCron, {
          now: moment('2014-10-09 06:30:00'),
          dayStart: dayStart
        });
        return expect(days).to.eql(0);
      });
      it('daysSince cron after, now tomorrow before', function() {
        var days, lastCron;
        lastCron = moment('2014-10-09 12:30:00');
        days = shared.daysSince(lastCron, {
          now: moment('2014-10-10 01:30:00'),
          dayStart: dayStart
        });
        return expect(days).to.eql(0);
      });
      it('daysSince cron after, now tomorrow after', function() {
        var days, lastCron;
        lastCron = moment('2014-10-09 12:30:00');
        days = shared.daysSince(lastCron, {
          now: moment('2014-10-10 10:30:00'),
          dayStart: dayStart
        });
        return expect(days).to.eql(1);
      });
      return xit('daysSince, last cron before new dayStart', function() {
        var days, lastCron;
        lastCron = moment('2014-10-09 01:00:00');
        days = shared.daysSince(lastCron, {
          now: moment('2014-10-09 05:00:00'),
          dayStart: dayStart
        });
        return expect(days).to.eql(0);
      });
    });
    return describe('dailies', function() {
      return describe('new day', function() {
        /*
              This section runs through a "cron matrix" of all permutations (that I can easily account for). It sets
              task due days, user custom day start, timezoneOffset, etc - then runs cron, jumps to tomorrow and runs cron,
              and so on - testing each possible outcome along the way
        */

        var cronMatrix, recurseCronMatrix, runCron;
        runCron = function(options) {
          return _.each([480, 240, 0, -120], function(timezoneOffset) {
            var after, before, now, _ref;
            now = shared.startOfWeek({
              timezoneOffset: timezoneOffset
            }).add(options.currentHour || 0, 'hours');
            _ref = beforeAfter({
              now: now,
              timezoneOffset: timezoneOffset,
              daysAgo: 1,
              cronAfterStart: options.cronAfterStart || true,
              dayStart: options.dayStart || 0,
              limitOne: 'daily'
            }), before = _ref.before, after = _ref.after;
            if (options.repeat) {
              before.dailys[0].repeat = after.dailys[0].repeat = options.repeat;
            }
            before.dailys[0].streak = after.dailys[0].streak = 10;
            if (options.checked) {
              before.dailys[0].completed = after.dailys[0].completed = true;
            }
            before.dailys[0].startDate = after.dailys[0].startDate = moment().subtract(30, 'days');
            if (options.shouldDo) {
              expect(shared.shouldDo(now.toDate(), after.dailys[0], {
                timezoneOffset: timezoneOffset,
                dayStart: options.dayStart,
                now: now
              })).to.be.ok();
            }
            after.fns.cron({
              now: now
            });
            before.stats.mp = after.stats.mp;
            switch (options.expect) {
              case 'losePoints':
                expectLostPoints(before, after, 'daily');
                break;
              case 'noChange':
                expectNoChange(before, after);
                break;
              case 'noDamage':
                expectDayResetNoDamage(before, after);
            }
            return {
              before: before,
              after: after
            };
          });
        };
        cronMatrix = {
          steps: {
            'due yesterday': {
              defaults: {
                daysAgo: 1,
                cronAfterStart: true,
                limitOne: 'daily'
              },
              steps: {
                '(simple)': {
                  expect: 'losePoints'
                },
                'due today': {
                  defaults: {
                    repeat: {
                      su: true,
                      m: true,
                      t: true,
                      w: true,
                      th: true,
                      f: true,
                      s: true
                    }
                  },
                  steps: {
                    'pre-dayStart': {
                      defaults: {
                        currentHour: 3,
                        dayStart: 4,
                        shouldDo: true
                      },
                      steps: {
                        'checked': {
                          checked: true,
                          expect: 'noChange'
                        },
                        'un-checked': {
                          checked: false,
                          expect: 'noChange'
                        }
                      }
                    },
                    'post-dayStart': {
                      defaults: {
                        currentHour: 5,
                        dayStart: 4,
                        shouldDo: true
                      },
                      steps: {
                        'checked': {
                          checked: true,
                          expect: 'noDamage'
                        },
                        'unchecked': {
                          checked: false,
                          expect: 'losePoints'
                        }
                      }
                    }
                  }
                },
                'NOT due today': {
                  defaults: {
                    repeat: {
                      su: true,
                      m: false,
                      t: true,
                      w: true,
                      th: true,
                      f: true,
                      s: true
                    }
                  },
                  steps: {
                    'pre-dayStart': {
                      defaults: {
                        currentHour: 3,
                        dayStart: 4,
                        shouldDo: true
                      },
                      steps: {
                        'checked': {
                          checked: true,
                          expect: 'noChange'
                        },
                        'un-checked': {
                          checked: false,
                          expect: 'noChange'
                        }
                      }
                    },
                    'post-dayStart': {
                      defaults: {
                        currentHour: 5,
                        dayStart: 4,
                        shouldDo: false
                      },
                      steps: {
                        'checked': {
                          checked: true,
                          expect: 'noDamage'
                        },
                        'unchecked': {
                          checked: false,
                          expect: 'losePoints'
                        }
                      }
                    }
                  }
                }
              }
            },
            'not due yesterday': {
              defaults: repeatWithoutLastWeekday(),
              steps: {
                '(simple)': {
                  expect: 'noDamage'
                },
                'post-dayStart': {
                  currentHour: 5,
                  dayStart: 4,
                  expect: 'noDamage'
                },
                'pre-dayStart': {
                  currentHour: 3,
                  dayStart: 4,
                  expect: 'noChange'
                }
              }
            }
          }
        };
        recurseCronMatrix = function(obj, options) {
          if (options == null) {
            options = {};
          }
          if (obj.steps) {
            return _.each(obj.steps, function(step, text) {
              var o, _ref;
              o = _.cloneDeep(options);
              if ((_ref = o.text) == null) {
                o.text = '';
              }
              o.text += " " + text + " ";
              return recurseCronMatrix(step, _.defaults(o, obj.defaults));
            });
          } else {
            return it("" + options.text, function() {
              return runCron(_.defaults(obj, options));
            });
          }
        };
        return recurseCronMatrix(cronMatrix);
      });
    });
  });

}).call(this);
